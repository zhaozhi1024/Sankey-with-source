import * as _ from 'lodash';

import * as d3 from 'd3';

export interface SankeyData {
  columns: Node[][];
  links: Link[];
}
export interface Node {
  id: string;
  label: string;
  value: number;

  color?: string;
}
export interface Link {
  sourceChain: string[];
  source: string | Node;
  target: string | Node;
  value: number;

  // be used to remove repeated data
  inpatIds: string[];
  // generated by function parseData
  linkGroupIndex?: number;
}

export class SankeyDataParse {
  private columnMap: Map<number, string[]>;

  private chain: string[] = [];
  private otherLinks: Link[] = [];
  private columnCount = 0;
  private linkGroupIndexArray: number[] = [];
  private jumpLevelLinks: Link[] = [];

  data: SankeyData;
  constructor(data: SankeyData) {
    // this.data = {
    //     columns: [
    //         [
    //             { id: '0', name: "极高危", value: 80, color: '#757DFE' },
    //             { id: '1', name: "高危", value: 80, color: '#FF6DB7' },
    //             { id: '11', name: "低危", value: 80, color: '#FF6DB7' },

    //         ], [
    //             { id: '2', name: "未预防", value: 80, color: '#7540EE' },
    //             { id: '3', name: "药物预防", value: 80, color: '#69c6d7' },
    //             { id: '21', name: "机械预防", value: 80, color: '#69c6d7' }
    //         ],
    //         [
    //             { id: '4', name: "低分子肝素钠", value: 80, color: '#05C8CF' },
    //             { id: '5', name: "利伐沙班", value: 80, color: '#5B79FB' },
    //             { id: '31', name: "利伐沙班", value: 80, color: '#5B79FB' },

    //         ],
    //         [
    //             { id: '6', name: "低分子肝素钠", value: 80, color: 'black' },
    //             { id: '7', name: "利伐沙班", value: 80, color: 'yellow' },
    //             { id: '41', name: "利伐沙班", value: 80, color: 'yellow' },
    //         ],
    //         [
    //             { id: '8', name: "低分子肝素钠", value: 80, color: 'red' },
    //             { id: '9', name: "利伐沙班", value: 80, color: 'lightblue' },
    //             { id: '51', name: "利伐沙班", value: 80, color: 'yellow' },
    //         ]
    //     ],
    //     links: [
    //     ]
    // };
    const color = [
      ['#b79afd', '#e87052', '#e6c751', '#95f5bc'],
      [
        '#b0d212',
        '#2d40b7',
        '#2f62d5',
        '#3073e9',
        '#e25417',
        '#f27c1d',
        '#ec9620',
        '#7540ee',
        '#DA70D6',
        '#DC143C',
        '#FF00FF',
        '#9932CC',
      ],
      [
        '#5e2243',
        '#b12572',
        '#9013fe',
        '#cb5f9a',
        '#f64da9',
        '#ffc800',
        '#f8e71c',
      ],
      ['#25265d', '#373844', '#787993', '#2dc76d'],
      ['#404048', '#2dc76d', '#9b9b9b'],
    ];
    this.data = data;
    this.columnMap = new Map<number, string[]>();
    // console.log(this.data.columns);
    this.data.columns.forEach((colm: Node[], i) => {
      colm.forEach((node, j) => {
        if (!node.color || node.color.length === 0) {
          node.color = color[i][j];
        }
      });
      this.data.columns[i] = colm.filter(node => node.value > 0);
    });
    this.data.columns = _.dropRightWhile(this.data.columns, colm => {
      return colm.length === 0;
    });
    this.data.columns.forEach((colm: Node[], i) => {
      this.columnMap.set(
        i,
        this.data.columns[i].map((node, j) => {
          return node.id;
        })
      );
    });
    // console.log(this.data.columns);
    this.columnCount = this.data.columns.length;
  }

  private initLinkData() {
    this.untilLastCol(0, 0, this.data.columns.length - 1, false);
    this.data.links = [];
    this.data.links = this.otherLinks;
    this.data.links.forEach(link => {
      link.value = 10;
    });
    this.otherLinks = [];
  }

  parseData() {
    // this.initLinkData();
    const columnCount = this.data.columns.length;
    // init link group index
    for (let i = 0; i < this.data.links.length; i++) {
      this.data.links[i].linkGroupIndex = 0;
    }
    this.getJumpLevelLinks();

    for (let i = 0; i < columnCount - 1; i++) {
      if (i === 0) {
        for (let end = columnCount - 2; end > 0; end--) {
          if (i < end) {
            this.untilLastCol(i, i, end, false);
          }
        }
      } else {
        for (let end = columnCount - 1; end > 0; end--) {
          if (i < end) {
            this.untilLastCol(i, i, end, false);
          }
        }
      }
      this.linkGroupIndexArray.push(i);
    }

    this.chain = [];
    for (let i = columnCount - 1; i >= 0; i--) {
      for (let end = 0; end < columnCount - 1; end++) {
        if (i > end) {
          this.untilLastCol(i + columnCount, i, end, true);
        }
      }
      this.linkGroupIndexArray.push(i + columnCount);
    }

    this.data.links = this.data.links.concat(this.otherLinks);
    this.removeDataValueIsZero();
    this.handleJumpLevelLinks();
    this.mergeScatteredData();
  }

  private reomveItemsFromArray(array: any[], items: any[]) {
    items.forEach(item => {
      const i = array.indexOf(item);
      i > -1 ? array.splice(i, 1) : '';
    });
  }

  private removeDataValueIsZero() {
    const linksClone = _.clone(this.data.links);
    linksClone.forEach(link => {
      if (link.value === 0) {
        this.reomveItemsFromArray(this.data.links, [link]);
      }
    });
  }
  private mergeScatteredData() {
    this.linkGroupIndexArray.sort((a, b) => a - b);
    // console.log(this.linkGroupIndexArray);

    // let array = _.clone(this.linkGroupIndexArray);

    this.linkGroupIndexArray.forEach(groupIndex => {
      if (groupIndex < this.columnCount) {
        this.columnMap.get(groupIndex).forEach(firstChain => {
          for (let j = 0; j < this.columnCount; j++) {
            if (groupIndex + j + 1 <= this.columnCount - 1) {
              this.columnMap.get(groupIndex + j).forEach(source => {
                for (
                  let interval = 1;
                  interval <= this.columnCount - 1 - groupIndex - j;
                  interval++
                ) {
                  this.columnMap
                    .get(groupIndex + j + interval)
                    .forEach(target => {
                      const scatteredData = this.data.links.filter(
                        link =>
                          link.linkGroupIndex === groupIndex &&
                          link.sourceChain[0] === firstChain &&
                          link.source === source &&
                          link.target === target
                      );
                      if (scatteredData.length > 1) {
                        this.reomveItemsFromArray(
                          this.data.links,
                          scatteredData
                        );
                        const inpatIds = [];
                        scatteredData.forEach(scaData => {
                          scaData.inpatIds.forEach(id => {
                            inpatIds.push(id);
                          });
                        });
                        const newLink: Link = {
                          source: source,
                          target: target,
                          sourceChain: [firstChain, source, target],
                          linkGroupIndex: groupIndex,
                          value: d3.sum(scatteredData, link => link.value),
                          inpatIds: inpatIds,
                        };
                        this.data.links.push(newLink);
                      }
                    });
                }
              });
            }
          }
        });
      } else {
        this.columnMap
          .get(groupIndex - this.columnCount)
          .forEach(firstChain => {
            for (let j = 0; j < this.columnCount; j++) {
              if (groupIndex - this.columnCount - j - 1 >= 0) {
                this.columnMap
                  .get(groupIndex - this.columnCount - j)
                  .forEach(source => {
                    for (
                      let interval = 1;
                      interval <= groupIndex - this.columnCount - j;
                      interval++
                    ) {
                      this.columnMap
                        .get(groupIndex - this.columnCount - j - interval)
                        .forEach(target => {
                          const scatteredData = this.data.links.filter(
                            link =>
                              link.linkGroupIndex === groupIndex &&
                              link.sourceChain[0] === firstChain &&
                              link.source === source &&
                              link.target === target
                          );
                          if (scatteredData.length > 1) {
                            this.reomveItemsFromArray(
                              this.data.links,
                              scatteredData
                            );
                            const inpatIds = [];
                            scatteredData.forEach(scaData => {
                              scaData.inpatIds.forEach(id => {
                                inpatIds.push(id);
                              });
                            });
                            const newLink: Link = {
                              source: source,
                              target: target,
                              sourceChain: [firstChain, source, target],
                              linkGroupIndex: groupIndex,
                              value: d3.sum(scatteredData, link => link.value),
                              inpatIds: inpatIds,
                            };
                            this.data.links.push(newLink);
                          }
                        });
                    }
                  });
              }
            }
          });
      }
    });
  }

  private getColIndexFromId(id: string): number {
    let result: number;
    for (let i = 0; i < this.columnMap.size; i++) {
      if (this.columnMap.get(i).indexOf(id) > -1) {
        result = i;
        break;
      }
    }
    return result;
  }

  private getJumpLevelLinks() {
    const jump: string[][] = [];
    const jumpLevelLinks = this.data.links.filter(link => {
      let isHas = false;
      for (let i = 0; i < link.sourceChain.length; i++) {
        let chain1, chain2;
        chain1 = this.getColIndexFromId(link.sourceChain[i]);
        chain2 = this.getColIndexFromId(link.sourceChain[i + 1]);
        if (chain2 - chain1 > 1) {
          isHas = true;
          jump.push([link.sourceChain[i], link.sourceChain[i + 1]]);
          break;
        }
      }
      return isHas;
    });
    this.reomveItemsFromArray(this.data.links, jumpLevelLinks);
    this.jumpLevelLinks = jumpLevelLinks;
  }
  private handleJumpLevelLinks() {
    const newLinks: Link[] = [];
    this.jumpLevelLinks.forEach(link => {
      for (let i = 0; i < link.sourceChain.length - 1; i++) {
        for (let j = i; j <= link.sourceChain.length - 2; j++) {
          const linkGroupIndex = this.getColIndexFromId(link.sourceChain[i]);
          const source = link.sourceChain[j];
          const target = link.sourceChain[j + 1];
          const tempLink: Link = {
            source: source,
            target: target,
            sourceChain:
              j === i
                ? [source, target]
                : [link.sourceChain[i], source, target],
            linkGroupIndex: linkGroupIndex,
            value: link.value,
            inpatIds: link.inpatIds,
          };
          newLinks.push(tempLink);
        }
      }
      for (let i = link.sourceChain.length - 1; i > 0; i--) {
        for (let j = i; j >= 1; j--) {
          const linkGroupIndex = this.getColIndexFromId(link.sourceChain[i]);
          const source = link.sourceChain[j];
          const target = link.sourceChain[j - 1];
          const tempLink: Link = {
            source: source,
            target: target,
            sourceChain:
              j === i
                ? [source, target]
                : [link.sourceChain[i], source, target],
            linkGroupIndex: linkGroupIndex + this.columnCount,
            value: link.value,
            inpatIds: link.inpatIds,
          };
          newLinks.push(tempLink);
        }
      }
    });

    newLinks.forEach(link => {
      // let isInsert=false;
      // isInsert = this.test(link, jump);
      // if(isInsert){
      //     insertLinks.push(link);
      //     this.data.links.push(link);
      // }
      this.data.links.push(link);
    });
  }

  private untilLastCol(
    linkGroupIndex,
    startCol: number,
    endCol: number,
    isReverse: boolean
  ) {
    // if (chain == null) {
    //     chain=[];
    // }
    if (isReverse) {
      if (startCol >= endCol) {
        for (let k = 0; k < this.columnMap.get(startCol).length; k++) {
          while (
            this.chain.length >
            linkGroupIndex - this.columnMap.size - startCol
          ) {
            this.chain.pop();
          }
          this.chain.push(this.columnMap.get(startCol)[k]);
          // console.log( this.chain);
          this.untilLastCol(linkGroupIndex, startCol - 1, endCol, isReverse);
        }
      } else {
        const link = {
          source: '',
          sourceChain: [],
          target: '',
          value: 0,
          linkGroupIndex: linkGroupIndex,
          inpatIds: [],
        };
        this.chain.forEach(item => {
          link.sourceChain.push(item);
        });
        link.source = link.sourceChain[link.sourceChain.length - 2];
        link.target = link.sourceChain[link.sourceChain.length - 1];
        const filterData = this.data.links.filter(item => {
          let isHas = true;
          for (let i = 0; i < link.sourceChain.length; i++) {
            if (item.sourceChain.indexOf(link.sourceChain[i]) === -1) {
              isHas = false;
              break;
            }
          }
          if (
            isHas &&
            item.sourceChain.length === link.sourceChain.length &&
            item.sourceChain[0] === link.sourceChain[0]
          ) {
            return false;
          }
          return isHas;
        });

        link.value = d3.sum(filterData, a => a.value);
        filterData.forEach(item => {
          item.inpatIds.forEach(id => {
            link.inpatIds.push(id);
          });
        });
        this.otherLinks.push(_.clone(link));
      }
    } else {
      if (startCol <= endCol) {
        for (let k = 0; k < this.columnMap.get(startCol).length; k++) {
          while (this.chain.length > startCol - linkGroupIndex) {
            this.chain.pop();
          }
          this.chain.push(this.columnMap.get(startCol)[k]);
          // console.log( this.chain);
          this.untilLastCol(linkGroupIndex, startCol + 1, endCol, isReverse);
        }
      } else {
        const link = {
          sourceChain: [],
          source: '',
          target: '',
          value: 0,
          linkGroupIndex: linkGroupIndex,
          inpatIds: [],
        };
        this.chain.forEach(item => {
          link.sourceChain.push(item);
        });
        link.source = link.sourceChain[link.sourceChain.length - 2];
        link.target = link.sourceChain[link.sourceChain.length - 1];
        const filterData = this.data.links.filter(item => {
          let isHas = true;
          for (let i = 0; i < link.sourceChain.length; i++) {
            if (item.sourceChain.indexOf(link.sourceChain[i]) === -1) {
              isHas = false;
              break;
            }
          }
          if (
            isHas &&
            item.sourceChain.length === link.sourceChain.length &&
            item.sourceChain[0] === link.sourceChain[0]
          ) {
            return false;
          }
          return isHas;
        });
        link.value = d3.sum(filterData, a => a.value);
        filterData.forEach(item => {
          item.inpatIds.forEach(id => {
            link.inpatIds.push(id);
          });
        });
        this.otherLinks.push(_.clone(link));
      }
    }
  }

  private test(link: Link, jump: string[][]) {
    let isInsert = false;
    jump.forEach(st => {
      if (link.source === st[0] && link.target === st[1]) {
        isInsert = true;
      }
      if (link.source === st[1] && link.target === st[1]) {
        isInsert = true;
      }
    });
    isInsert = true;
    return isInsert;
  }
  private arrayIsEqual(array1: any[], array2: any[]) {
    let isEqual = true;
    for (let i = 0; i < array1.length; i++) {
      if (array2.indexOf(array1[i]) === -1) {
        isEqual = false;
        break;
      }
    }
    if (isEqual && array2.length === array1.length && array2[0] === array1[0]) {
      isEqual = true;
    } else {
      isEqual = false;
    }
    return isEqual;
  }
}
